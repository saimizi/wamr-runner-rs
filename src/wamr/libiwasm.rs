/* automatically generated by rust-bindgen 0.60.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NativeSymbol {
    pub symbol: *const ::std::os::raw::c_char,
    pub func_ptr: *mut ::std::os::raw::c_void,
    pub signature: *const ::std::os::raw::c_char,
    pub attachment: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_NativeSymbol() {
    assert_eq!(
        ::std::mem::size_of::<NativeSymbol>(),
        32usize,
        concat!("Size of: ", stringify!(NativeSymbol))
    );
    assert_eq!(
        ::std::mem::align_of::<NativeSymbol>(),
        8usize,
        concat!("Alignment of ", stringify!(NativeSymbol))
    );
    fn test_field_symbol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NativeSymbol>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbol) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NativeSymbol),
                "::",
                stringify!(symbol)
            )
        );
    }
    test_field_symbol();
    fn test_field_func_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NativeSymbol>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(NativeSymbol),
                "::",
                stringify!(func_ptr)
            )
        );
    }
    test_field_func_ptr();
    fn test_field_signature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NativeSymbol>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(NativeSymbol),
                "::",
                stringify!(signature)
            )
        );
    }
    test_field_signature();
    fn test_field_attachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NativeSymbol>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachment) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(NativeSymbol),
                "::",
                stringify!(attachment)
            )
        );
    }
    test_field_attachment();
}
extern "C" {
    #[doc = " Get the exported APIs of base lib"]
    #[doc = ""]
    #[doc = " @param p_base_lib_apis return the exported API array of base lib"]
    #[doc = ""]
    #[doc = " @return the number of the exported API"]
    pub fn get_base_lib_export_apis(p_base_lib_apis: *mut *mut NativeSymbol) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WASMModuleCommon {
    _unused: [u8; 0],
}
pub type wasm_module_t = *mut WASMModuleCommon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WASMModuleInstanceCommon {
    _unused: [u8; 0],
}
pub type wasm_module_inst_t = *mut WASMModuleInstanceCommon;
pub type WASMFunctionInstanceCommon = ::std::os::raw::c_void;
pub type wasm_function_inst_t = *mut WASMFunctionInstanceCommon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_section_t {
    pub next: *mut wasm_section_t,
    pub section_type: ::std::os::raw::c_int,
    pub section_body: *mut u8,
    pub section_body_size: u32,
}
#[test]
fn bindgen_test_layout_wasm_section_t() {
    assert_eq!(
        ::std::mem::size_of::<wasm_section_t>(),
        32usize,
        concat!("Size of: ", stringify!(wasm_section_t))
    );
    assert_eq!(
        ::std::mem::align_of::<wasm_section_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wasm_section_t))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_section_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_section_t),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_section_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_section_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).section_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_section_t),
                "::",
                stringify!(section_type)
            )
        );
    }
    test_field_section_type();
    fn test_field_section_body() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_section_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).section_body) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_section_t),
                "::",
                stringify!(section_body)
            )
        );
    }
    test_field_section_body();
    fn test_field_section_body_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_section_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).section_body_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_section_t),
                "::",
                stringify!(section_body_size)
            )
        );
    }
    test_field_section_body_size();
}
pub type aot_section_t = wasm_section_t;
pub type wasm_section_list_t = *mut wasm_section_t;
pub type aot_section_list_t = *mut wasm_section_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WASMExecEnv {
    _unused: [u8; 0],
}
pub type wasm_exec_env_t = *mut WASMExecEnv;
pub const package_type_t_Wasm_Module_Bytecode: package_type_t = 0;
pub const package_type_t_Wasm_Module_AoT: package_type_t = 1;
pub const package_type_t_Package_Type_Unknown: package_type_t = 65535;
pub type package_type_t = ::std::os::raw::c_uint;
pub const mem_alloc_type_t_Alloc_With_Pool: mem_alloc_type_t = 0;
pub const mem_alloc_type_t_Alloc_With_Allocator: mem_alloc_type_t = 1;
pub const mem_alloc_type_t_Alloc_With_System_Allocator: mem_alloc_type_t = 2;
pub type mem_alloc_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemAllocOption {
    pub pool: MemAllocOption__bindgen_ty_1,
    pub allocator: MemAllocOption__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemAllocOption__bindgen_ty_1 {
    pub heap_buf: *mut ::std::os::raw::c_void,
    pub heap_size: u32,
}
#[test]
fn bindgen_test_layout_MemAllocOption__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MemAllocOption__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MemAllocOption__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MemAllocOption__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MemAllocOption__bindgen_ty_1))
    );
    fn test_field_heap_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heap_buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption__bindgen_ty_1),
                "::",
                stringify!(heap_buf)
            )
        );
    }
    test_field_heap_buf();
    fn test_field_heap_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heap_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption__bindgen_ty_1),
                "::",
                stringify!(heap_size)
            )
        );
    }
    test_field_heap_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemAllocOption__bindgen_ty_2 {
    pub malloc_func: *mut ::std::os::raw::c_void,
    pub realloc_func: *mut ::std::os::raw::c_void,
    pub free_func: *mut ::std::os::raw::c_void,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MemAllocOption__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MemAllocOption__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(MemAllocOption__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<MemAllocOption__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(MemAllocOption__bindgen_ty_2))
    );
    fn test_field_malloc_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).malloc_func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption__bindgen_ty_2),
                "::",
                stringify!(malloc_func)
            )
        );
    }
    test_field_malloc_func();
    fn test_field_realloc_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).realloc_func) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption__bindgen_ty_2),
                "::",
                stringify!(realloc_func)
            )
        );
    }
    test_field_realloc_func();
    fn test_field_free_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption__bindgen_ty_2),
                "::",
                stringify!(free_func)
            )
        );
    }
    test_field_free_func();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption__bindgen_ty_2),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
}
#[test]
fn bindgen_test_layout_MemAllocOption() {
    assert_eq!(
        ::std::mem::size_of::<MemAllocOption>(),
        32usize,
        concat!("Size of: ", stringify!(MemAllocOption))
    );
    assert_eq!(
        ::std::mem::align_of::<MemAllocOption>(),
        8usize,
        concat!("Alignment of ", stringify!(MemAllocOption))
    );
    fn test_field_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption),
                "::",
                stringify!(pool)
            )
        );
    }
    test_field_pool();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MemAllocOption>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MemAllocOption),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_alloc_info_t {
    pub total_size: u32,
    pub total_free_size: u32,
    pub highmark_size: u32,
}
#[test]
fn bindgen_test_layout_mem_alloc_info_t() {
    assert_eq!(
        ::std::mem::size_of::<mem_alloc_info_t>(),
        12usize,
        concat!("Size of: ", stringify!(mem_alloc_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_alloc_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mem_alloc_info_t))
    );
    fn test_field_total_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mem_alloc_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_alloc_info_t),
                "::",
                stringify!(total_size)
            )
        );
    }
    test_field_total_size();
    fn test_field_total_free_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mem_alloc_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_free_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_alloc_info_t),
                "::",
                stringify!(total_free_size)
            )
        );
    }
    test_field_total_free_size();
    fn test_field_highmark_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mem_alloc_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).highmark_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_alloc_info_t),
                "::",
                stringify!(highmark_size)
            )
        );
    }
    test_field_highmark_size();
}
pub const RunningMode_Mode_Interp: RunningMode = 1;
pub const RunningMode_Mode_Fast_JIT: RunningMode = 2;
pub const RunningMode_Mode_LLVM_JIT: RunningMode = 3;
pub const RunningMode_Mode_Multi_Tier_JIT: RunningMode = 4;
pub type RunningMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RuntimeInitArgs {
    pub mem_alloc_type: mem_alloc_type_t,
    pub mem_alloc_option: MemAllocOption,
    pub native_module_name: *const ::std::os::raw::c_char,
    pub native_symbols: *mut NativeSymbol,
    pub n_native_symbols: u32,
    pub max_thread_num: u32,
    pub ip_addr: [::std::os::raw::c_char; 128usize],
    pub unused: ::std::os::raw::c_int,
    pub instance_port: ::std::os::raw::c_int,
    pub fast_jit_code_cache_size: u32,
    pub running_mode: RunningMode,
    pub llvm_jit_opt_level: u32,
    pub llvm_jit_size_level: u32,
}
#[test]
fn bindgen_test_layout_RuntimeInitArgs() {
    assert_eq!(
        ::std::mem::size_of::<RuntimeInitArgs>(),
        216usize,
        concat!("Size of: ", stringify!(RuntimeInitArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeInitArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeInitArgs))
    );
    fn test_field_mem_alloc_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_alloc_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(mem_alloc_type)
            )
        );
    }
    test_field_mem_alloc_type();
    fn test_field_mem_alloc_option() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_alloc_option) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(mem_alloc_option)
            )
        );
    }
    test_field_mem_alloc_option();
    fn test_field_native_module_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).native_module_name) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(native_module_name)
            )
        );
    }
    test_field_native_module_name();
    fn test_field_native_symbols() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).native_symbols) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(native_symbols)
            )
        );
    }
    test_field_native_symbols();
    fn test_field_n_native_symbols() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_native_symbols) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(n_native_symbols)
            )
        );
    }
    test_field_n_native_symbols();
    fn test_field_max_thread_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_thread_num) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(max_thread_num)
            )
        );
    }
    test_field_max_thread_num();
    fn test_field_ip_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(ip_addr)
            )
        );
    }
    test_field_ip_addr();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
    fn test_field_instance_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instance_port) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(instance_port)
            )
        );
    }
    test_field_instance_port();
    fn test_field_fast_jit_code_cache_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fast_jit_code_cache_size) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(fast_jit_code_cache_size)
            )
        );
    }
    test_field_fast_jit_code_cache_size();
    fn test_field_running_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).running_mode) as usize - ptr as usize
            },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(running_mode)
            )
        );
    }
    test_field_running_mode();
    fn test_field_llvm_jit_opt_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).llvm_jit_opt_level) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(llvm_jit_opt_level)
            )
        );
    }
    test_field_llvm_jit_opt_level();
    fn test_field_llvm_jit_size_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RuntimeInitArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).llvm_jit_size_level) as usize - ptr as usize
            },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(RuntimeInitArgs),
                "::",
                stringify!(llvm_jit_size_level)
            )
        );
    }
    test_field_llvm_jit_size_level();
}
pub type wasm_valkind_t = u8;
pub const wasm_valkind_enum_WASM_I32: wasm_valkind_enum = 0;
pub const wasm_valkind_enum_WASM_I64: wasm_valkind_enum = 1;
pub const wasm_valkind_enum_WASM_F32: wasm_valkind_enum = 2;
pub const wasm_valkind_enum_WASM_F64: wasm_valkind_enum = 3;
pub const wasm_valkind_enum_WASM_ANYREF: wasm_valkind_enum = 128;
pub const wasm_valkind_enum_WASM_FUNCREF: wasm_valkind_enum = 129;
pub type wasm_valkind_enum = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wasm_val_t {
    pub kind: wasm_valkind_t,
    pub of: wasm_val_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wasm_val_t__bindgen_ty_1 {
    pub i32_: i32,
    pub i64_: i64,
    pub f32_: f32,
    pub f64_: f64,
    pub foreign: usize,
}
#[test]
fn bindgen_test_layout_wasm_val_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wasm_val_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wasm_val_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wasm_val_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wasm_val_t__bindgen_ty_1))
    );
    fn test_field_i32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t__bindgen_ty_1),
                "::",
                stringify!(i32_)
            )
        );
    }
    test_field_i32();
    fn test_field_i64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t__bindgen_ty_1),
                "::",
                stringify!(i64_)
            )
        );
    }
    test_field_i64();
    fn test_field_f32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t__bindgen_ty_1),
                "::",
                stringify!(f32_)
            )
        );
    }
    test_field_f32();
    fn test_field_f64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t__bindgen_ty_1),
                "::",
                stringify!(f64_)
            )
        );
    }
    test_field_f64();
    fn test_field_foreign() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).foreign) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t__bindgen_ty_1),
                "::",
                stringify!(foreign)
            )
        );
    }
    test_field_foreign();
}
#[test]
fn bindgen_test_layout_wasm_val_t() {
    assert_eq!(
        ::std::mem::size_of::<wasm_val_t>(),
        16usize,
        concat!("Size of: ", stringify!(wasm_val_t))
    );
    assert_eq!(
        ::std::mem::align_of::<wasm_val_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wasm_val_t))
    );
    fn test_field_kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t),
                "::",
                stringify!(kind)
            )
        );
    }
    test_field_kind();
    fn test_field_of() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wasm_val_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).of) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(wasm_val_t),
                "::",
                stringify!(of)
            )
        );
    }
    test_field_of();
}
extern "C" {
    #[doc = " Initialize the WASM runtime environment, and also initialize"]
    #[doc = " the memory allocator with system allocator, which calls os_malloc"]
    #[doc = " to allocate memory"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_init() -> bool;
}
extern "C" {
    #[doc = " Initialize the WASM runtime environment, WASM running mode,"]
    #[doc = " and also initialize the memory allocator and register native symbols,"]
    #[doc = " which are specified with init arguments"]
    #[doc = ""]
    #[doc = " @param init_args specifies the init arguments"]
    #[doc = ""]
    #[doc = " @return return true if success, false otherwise"]
    pub fn wasm_runtime_full_init(init_args: *mut RuntimeInitArgs) -> bool;
}
extern "C" {
    #[doc = " Query whether a certain running mode is supported for the runtime"]
    #[doc = ""]
    #[doc = " @param running_mode the running mode to query"]
    #[doc = ""]
    #[doc = " @return true if this running mode is supported, false otherwise"]
    pub fn wasm_runtime_is_running_mode_supported(running_mode: RunningMode) -> bool;
}
extern "C" {
    #[doc = " Set the default running mode for the runtime. It is inherited"]
    #[doc = " to set the running mode of a module instance when it is instantiated,"]
    #[doc = " and can be changed by calling wasm_runtime_set_running_mode"]
    #[doc = ""]
    #[doc = " @param running_mode the running mode to set"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_set_default_running_mode(running_mode: RunningMode) -> bool;
}
extern "C" {
    #[doc = " Destroy the WASM runtime environment."]
    pub fn wasm_runtime_destroy();
}
extern "C" {
    #[doc = " Allocate memory from runtime memory environment."]
    #[doc = ""]
    #[doc = " @param size bytes need to allocate"]
    #[doc = ""]
    #[doc = " @return the pointer to memory allocated"]
    pub fn wasm_runtime_malloc(size: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Reallocate memory from runtime memory environment"]
    #[doc = ""]
    #[doc = " @param ptr the original memory"]
    #[doc = " @param size bytes need to reallocate"]
    #[doc = ""]
    #[doc = " @return the pointer to memory reallocated"]
    pub fn wasm_runtime_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wasm_runtime_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wasm_runtime_get_mem_alloc_info(mem_alloc_info: *mut mem_alloc_info_t) -> bool;
}
extern "C" {
    #[doc = " Get the package type of a buffer."]
    #[doc = ""]
    #[doc = " @param buf the package buffer"]
    #[doc = " @param size the package buffer size"]
    #[doc = ""]
    #[doc = " @return the package type, return Package_Type_Unknown if the type is unknown"]
    pub fn get_package_type(buf: *const u8, size: u32) -> package_type_t;
}
extern "C" {
    #[doc = " Check whether a file is an AOT XIP (Execution In Place) file"]
    #[doc = ""]
    #[doc = " @param buf the package buffer"]
    #[doc = " @param size the package buffer size"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_is_xip_file(buf: *const u8, size: u32) -> bool;
}
#[doc = " Callback to load a module file into a buffer in multi-module feature"]
pub type module_reader = ::std::option::Option<
    unsafe extern "C" fn(
        module_name: *const ::std::os::raw::c_char,
        p_buffer: *mut *mut u8,
        p_size: *mut u32,
    ) -> bool,
>;
#[doc = " Callback to release the buffer loaded by module_reader callback"]
pub type module_destroyer = ::std::option::Option<unsafe extern "C" fn(buffer: *mut u8, size: u32)>;
extern "C" {
    #[doc = " Setup callbacks for reading and releasing a buffer about a module file"]
    #[doc = ""]
    #[doc = " @param reader a callback to read a module file into a buffer"]
    #[doc = " @param destroyer a callback to release above buffer"]
    pub fn wasm_runtime_set_module_reader(reader: module_reader, destroyer: module_destroyer);
}
extern "C" {
    #[doc = " Give the \"module\" a name \"module_name\"."]
    #[doc = " Can not assign a new name to a module if it already has a name"]
    #[doc = ""]
    #[doc = " @param module_name indicate a name"]
    #[doc = " @param module the target module"]
    #[doc = " @param error_buf output of the exception info"]
    #[doc = " @param error_buf_size the size of the exception string"]
    #[doc = ""]
    #[doc = " @return true means success, false means failed"]
    pub fn wasm_runtime_register_module(
        module_name: *const ::std::os::raw::c_char,
        module: wasm_module_t,
        error_buf: *mut ::std::os::raw::c_char,
        error_buf_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if there is already a loaded module named module_name in the"]
    #[doc = " runtime. Repeately loading a module with the same name is not allowed."]
    #[doc = ""]
    #[doc = " @param module_name indicate a name"]
    #[doc = ""]
    #[doc = " @return return WASM module loaded, NULL if failed"]
    pub fn wasm_runtime_find_module_registered(
        module_name: *const ::std::os::raw::c_char,
    ) -> wasm_module_t;
}
extern "C" {
    #[doc = " Load a WASM module from a specified byte buffer. The byte buffer can be"]
    #[doc = " WASM binary data when interpreter or JIT is enabled, or AOT binary data"]
    #[doc = " when AOT is enabled. If it is AOT binary data, it must be 4-byte aligned."]
    #[doc = ""]
    #[doc = " Note: In case of AOT XIP modules, the runtime doesn't make modifications"]
    #[doc = " to the buffer. (Except the \"Known issues\" mentioned in doc/xip.md.)"]
    #[doc = " Otherwise, the runtime can make modifications to the buffer for its"]
    #[doc = " internal purposes. Thus, in general, it isn't safe to create multiple"]
    #[doc = " modules from a single buffer."]
    #[doc = ""]
    #[doc = " @param buf the byte buffer which contains the WASM/AOT binary data,"]
    #[doc = "        note that the byte buffer must be writable since runtime may"]
    #[doc = "        change its content for footprint and performance purpose, and"]
    #[doc = "        it must be referencable until wasm_runtime_unload is called"]
    #[doc = " @param size the size of the buffer"]
    #[doc = " @param error_buf output of the exception info"]
    #[doc = " @param error_buf_size the size of the exception string"]
    #[doc = ""]
    #[doc = " @return return WASM module loaded, NULL if failed"]
    pub fn wasm_runtime_load(
        buf: *mut u8,
        size: u32,
        error_buf: *mut ::std::os::raw::c_char,
        error_buf_size: u32,
    ) -> wasm_module_t;
}
extern "C" {
    #[doc = " Load a WASM module from a specified WASM or AOT section list."]
    #[doc = ""]
    #[doc = " @param section_list the section list which contains each section data"]
    #[doc = " @param is_aot whether the section list is AOT section list"]
    #[doc = " @param error_buf output of the exception info"]
    #[doc = " @param error_buf_size the size of the exception string"]
    #[doc = ""]
    #[doc = " @return return WASM module loaded, NULL if failed"]
    pub fn wasm_runtime_load_from_sections(
        section_list: wasm_section_list_t,
        is_aot: bool,
        error_buf: *mut ::std::os::raw::c_char,
        error_buf_size: u32,
    ) -> wasm_module_t;
}
extern "C" {
    #[doc = " Unload a WASM module."]
    #[doc = ""]
    #[doc = " @param module the module to be unloaded"]
    pub fn wasm_runtime_unload(module: wasm_module_t);
}
extern "C" {
    #[doc = " Get the module hash of a WASM module, currently only available on"]
    #[doc = " linux-sgx platform when the remote attestation feature is enabled"]
    #[doc = ""]
    #[doc = " @param module the WASM module to retrieve"]
    #[doc = ""]
    #[doc = " @return the module hash of the WASM module"]
    pub fn wasm_runtime_get_module_hash(module: wasm_module_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set WASI parameters."]
    #[doc = ""]
    #[doc = " While this API operates on a module, these parameters will be used"]
    #[doc = " only when the module is instantiated. That is, you can consider these"]
    #[doc = " as extra parameters for wasm_runtime_instantiate()."]
    #[doc = ""]
    #[doc = " @param module        The module to set WASI parameters."]
    #[doc = " @param dir_list      The list of directories to preopen. (real path)"]
    #[doc = " @param dir_count     The number of elements in dir_list."]
    #[doc = " @param map_dir_list  The list of directories to preopen. (mapped path)"]
    #[doc = " @param map_dir_count The number of elements in map_dir_list."]
    #[doc = "                      If map_dir_count is smaller than dir_count,"]
    #[doc = "                      mapped path is assumed to be same as the"]
    #[doc = "                      corresponding real path for the rest of entries."]
    #[doc = " @param env           The list of environment variables."]
    #[doc = " @param env_count     The number of elements in env."]
    #[doc = " @param argv          The list of command line arguments."]
    #[doc = " @param argc          The number of elements in argv."]
    #[doc = " @param stdinfd       The host file descriptor to back WASI STDIN_FILENO."]
    #[doc = "                      If -1 is specified, STDIN_FILENO is used."]
    #[doc = " @param stdoutfd      The host file descriptor to back WASI STDOUT_FILENO."]
    #[doc = "                      If -1 is specified, STDOUT_FILENO is used."]
    #[doc = " @param stderrfd      The host file descriptor to back WASI STDERR_FILENO."]
    #[doc = "                      If -1 is specified, STDERR_FILENO is used."]
    pub fn wasm_runtime_set_wasi_args_ex(
        module: wasm_module_t,
        dir_list: *mut *const ::std::os::raw::c_char,
        dir_count: u32,
        map_dir_list: *mut *const ::std::os::raw::c_char,
        map_dir_count: u32,
        env: *mut *const ::std::os::raw::c_char,
        env_count: u32,
        argv: *mut *mut ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        stdinfd: ::std::os::raw::c_int,
        stdoutfd: ::std::os::raw::c_int,
        stderrfd: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set WASI parameters."]
    #[doc = ""]
    #[doc = " Same as wasm_runtime_set_wasi_args_ex with stdinfd = -1, stdoutfd = -1,"]
    #[doc = " stderrfd = -1."]
    pub fn wasm_runtime_set_wasi_args(
        module: wasm_module_t,
        dir_list: *mut *const ::std::os::raw::c_char,
        dir_count: u32,
        map_dir_list: *mut *const ::std::os::raw::c_char,
        map_dir_count: u32,
        env: *mut *const ::std::os::raw::c_char,
        env_count: u32,
        argv: *mut *mut ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wasm_runtime_set_wasi_addr_pool(
        module: wasm_module_t,
        addr_pool: *mut *const ::std::os::raw::c_char,
        addr_pool_size: u32,
    );
}
extern "C" {
    pub fn wasm_runtime_set_wasi_ns_lookup_pool(
        module: wasm_module_t,
        ns_lookup_pool: *mut *const ::std::os::raw::c_char,
        ns_lookup_pool_size: u32,
    );
}
extern "C" {
    #[doc = " Instantiate a WASM module."]
    #[doc = ""]
    #[doc = " @param module the WASM module to instantiate"]
    #[doc = " @param default_stack_size the default stack size of the module instance when the"]
    #[doc = "        exec env's operation stack isn't created by user, e.g. API"]
    #[doc = "        wasm_application_execute_main() and wasm_application_execute_func()"]
    #[doc = "        create the operation stack internally with the stack size specified"]
    #[doc = "        here. And API wasm_runtime_create_exec_env() creates the operation"]
    #[doc = "        stack with stack size specified by its parameter, the stack size"]
    #[doc = "        specified here is ignored."]
    #[doc = " @param host_managed_heap_size the default heap size of the module instance, a heap will"]
    #[doc = "        be created besides the app memory space. Both wasm app and native"]
    #[doc = "        function can allocate memory from the heap."]
    #[doc = " @param error_buf buffer to output the error info if failed"]
    #[doc = " @param error_buf_size the size of the error buffer"]
    #[doc = ""]
    #[doc = " @return return the instantiated WASM module instance, NULL if failed"]
    pub fn wasm_runtime_instantiate(
        module: wasm_module_t,
        default_stack_size: u32,
        host_managed_heap_size: u32,
        error_buf: *mut ::std::os::raw::c_char,
        error_buf_size: u32,
    ) -> wasm_module_inst_t;
}
extern "C" {
    #[doc = " Set the running mode of a WASM module instance, override the"]
    #[doc = " default running mode of the runtime. Note that it only makes sense when"]
    #[doc = " the input is a wasm bytecode file: for the AOT file, runtime always runs"]
    #[doc = " it with AOT engine, and this function always returns true."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance to set running mode"]
    #[doc = " @param running_mode the running mode to set"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_set_running_mode(
        module_inst: wasm_module_inst_t,
        running_mode: RunningMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the running mode of a WASM module instance, if no running mode"]
    #[doc = " is explicitly set the default running mode of runtime will"]
    #[doc = " be used and returned. Note that it only makes sense when the input is a"]
    #[doc = " wasm bytecode file: for the AOT file, this function always returns 0."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance to query for running mode"]
    #[doc = ""]
    #[doc = " @return the running mode this module instance currently use"]
    pub fn wasm_runtime_get_running_mode(module_inst: wasm_module_inst_t) -> RunningMode;
}
extern "C" {
    #[doc = " Deinstantiate a WASM module instance, destroy the resources."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance to destroy"]
    pub fn wasm_runtime_deinstantiate(module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Get WASM module from WASM module instance"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance to retrieve"]
    #[doc = ""]
    #[doc = " @return the WASM module"]
    pub fn wasm_runtime_get_module(module_inst: wasm_module_inst_t) -> wasm_module_t;
}
extern "C" {
    pub fn wasm_runtime_is_wasi_mode(module_inst: wasm_module_inst_t) -> bool;
}
extern "C" {
    pub fn wasm_runtime_lookup_wasi_start_function(
        module_inst: wasm_module_inst_t,
    ) -> wasm_function_inst_t;
}
extern "C" {
    #[doc = " Get WASI exit code."]
    #[doc = ""]
    #[doc = " After a WASI command completed its execution, an embedder can"]
    #[doc = " call this function to get its exit code. (that is, the value given"]
    #[doc = " to proc_exit.)"]
    #[doc = ""]
    #[doc = " @param module_inst the module instance"]
    pub fn wasm_runtime_get_wasi_exit_code(module_inst: wasm_module_inst_t) -> u32;
}
extern "C" {
    #[doc = " Lookup an exported function in the WASM module instance."]
    #[doc = ""]
    #[doc = " @param module_inst the module instance"]
    #[doc = " @param name the name of the function"]
    #[doc = " @param signature the signature of the function, ignored currently"]
    #[doc = ""]
    #[doc = " @return the function instance found, NULL if not found"]
    pub fn wasm_runtime_lookup_function(
        module_inst: wasm_module_inst_t,
        name: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_char,
    ) -> wasm_function_inst_t;
}
extern "C" {
    #[doc = " Get parameter count of the function instance"]
    #[doc = ""]
    #[doc = " @param func_inst the function instance"]
    #[doc = " @param module_inst the module instance the function instance belongs to"]
    #[doc = ""]
    #[doc = " @return the parameter count of the function instance"]
    pub fn wasm_func_get_param_count(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
    ) -> u32;
}
extern "C" {
    #[doc = " Get result count of the function instance"]
    #[doc = ""]
    #[doc = " @param func_inst the function instance"]
    #[doc = " @param module_inst the module instance the function instance belongs to"]
    #[doc = ""]
    #[doc = " @return the result count of the function instance"]
    pub fn wasm_func_get_result_count(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
    ) -> u32;
}
extern "C" {
    #[doc = " Get parameter types of the function instance"]
    #[doc = ""]
    #[doc = " @param func_inst the function instance"]
    #[doc = " @param module_inst the module instance the function instance belongs to"]
    #[doc = " @param param_types the parameter types returned"]
    pub fn wasm_func_get_param_types(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
        param_types: *mut wasm_valkind_t,
    );
}
extern "C" {
    #[doc = " Get result types of the function instance"]
    #[doc = ""]
    #[doc = " @param func_inst the function instance"]
    #[doc = " @param module_inst the module instance the function instance belongs to"]
    #[doc = " @param result_types the result types returned"]
    pub fn wasm_func_get_result_types(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
        result_types: *mut wasm_valkind_t,
    );
}
extern "C" {
    #[doc = " Create execution environment for a WASM module instance."]
    #[doc = ""]
    #[doc = " @param module_inst the module instance"]
    #[doc = " @param stack_size the stack size to execute a WASM function"]
    #[doc = ""]
    #[doc = " @return the execution environment, NULL if failed, e.g. invalid"]
    #[doc = "         stack size is passed"]
    pub fn wasm_runtime_create_exec_env(
        module_inst: wasm_module_inst_t,
        stack_size: u32,
    ) -> wasm_exec_env_t;
}
extern "C" {
    #[doc = " Destroy the execution environment."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to destroy"]
    pub fn wasm_runtime_destroy_exec_env(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Get the singleton execution environment for the instance."]
    #[doc = ""]
    #[doc = " Note: The singleton execution environment is the execution"]
    #[doc = " environment used internally by the runtime for the API functions"]
    #[doc = " like wasm_application_execute_main, which don't take explicit"]
    #[doc = " execution environment. It's associated to the corresponding"]
    #[doc = " module instance and managed by the runtime. The API user should"]
    #[doc = " not destroy it with wasm_runtime_destroy_exec_env."]
    #[doc = ""]
    #[doc = " @param module_inst the module instance"]
    #[doc = ""]
    #[doc = " @return exec_env the execution environment to destroy"]
    pub fn wasm_runtime_get_exec_env_singleton(module_inst: wasm_module_inst_t) -> wasm_exec_env_t;
}
extern "C" {
    #[doc = " Start debug instance based on given execution environment."]
    #[doc = " Note:"]
    #[doc = "   The debug instance will be destroyed during destroying the"]
    #[doc = "   execution environment, developers don't need to destroy it"]
    #[doc = "   manually."]
    #[doc = "   If the cluster of this execution environment has already"]
    #[doc = "   been bound to a debug instance, this function will return true"]
    #[doc = "   directly."]
    #[doc = "   If developer spawns some exec_env by wasm_runtime_spawn_exec_env,"]
    #[doc = "   don't need to call this function for every spawned exec_env as"]
    #[doc = "   they are sharing the same cluster with the main exec_env."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to start debug instance"]
    #[doc = " @param port     the port for the debug server to listen on."]
    #[doc = "                 0 means automatic assignment."]
    #[doc = "                 -1 means to use the global setting in RuntimeInitArgs."]
    #[doc = ""]
    #[doc = " @return debug port if success, 0 otherwise."]
    pub fn wasm_runtime_start_debug_instance_with_port(exec_env: wasm_exec_env_t, port: i32)
        -> u32;
}
extern "C" {
    #[doc = " Same as wasm_runtime_start_debug_instance_with_port(env, -1)."]
    pub fn wasm_runtime_start_debug_instance(exec_env: wasm_exec_env_t) -> u32;
}
extern "C" {
    #[doc = " Initialize the thread environment."]
    #[doc = " Note:"]
    #[doc = "   If developer creates a child thread by himself to call the"]
    #[doc = "   the wasm function in that thread, he should call this API"]
    #[doc = "   firstly before calling the wasm function and then call"]
    #[doc = "   wasm_runtime_destroy_thread_env() after calling the wasm"]
    #[doc = "   function. If the thread is created from the runtime API,"]
    #[doc = "   it is unnecessary to call these two APIs."]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_init_thread_env() -> bool;
}
extern "C" {
    #[doc = " Destroy the thread environment"]
    pub fn wasm_runtime_destroy_thread_env();
}
extern "C" {
    #[doc = " Whether the thread environment is initialized"]
    pub fn wasm_runtime_thread_env_inited() -> bool;
}
extern "C" {
    #[doc = " Get WASM module instance from execution environment"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to retrieve"]
    #[doc = ""]
    #[doc = " @return the WASM module instance"]
    pub fn wasm_runtime_get_module_inst(exec_env: wasm_exec_env_t) -> wasm_module_inst_t;
}
extern "C" {
    #[doc = " Set WASM module instance of execution environment"]
    #[doc = " Caution:"]
    #[doc = "   normally the module instance is bound with the execution"]
    #[doc = "   environment one by one, if multiple module instances want"]
    #[doc = "   to share to the same execution environment, developer should"]
    #[doc = "   be responsible for the backup and restore of module instance"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    #[doc = " @param module_inst the WASM module instance to set"]
    pub fn wasm_runtime_set_module_inst(exec_env: wasm_exec_env_t, module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Call the given WASM function of a WASM module instance with"]
    #[doc = " arguments (bytecode and AoT)."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to call the function,"]
    #[doc = "   which must be created from wasm_create_exec_env()"]
    #[doc = " @param function the function to call"]
    #[doc = " @param argc total cell number that the function parameters occupy,"]
    #[doc = "   a cell is a slot of the uint32 array argv[], e.g. i32/f32 argument"]
    #[doc = "   occupies one cell, i64/f64 argument occupies two cells, note that"]
    #[doc = "   it might be different from the parameter number of the function"]
    #[doc = " @param argv the arguments. If the function has return value,"]
    #[doc = "   the first (or first two in case 64-bit return value) element of"]
    #[doc = "   argv stores the return value of the called WASM function after this"]
    #[doc = "   function returns."]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise and exception will be thrown,"]
    #[doc = "   the caller can call wasm_runtime_get_exception to get the exception"]
    #[doc = "   info."]
    pub fn wasm_runtime_call_wasm(
        exec_env: wasm_exec_env_t,
        function: wasm_function_inst_t,
        argc: u32,
        argv: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Call the given WASM function of a WASM module instance with"]
    #[doc = " provided results space and arguments (bytecode and AoT)."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to call the function,"]
    #[doc = "   which must be created from wasm_create_exec_env()"]
    #[doc = " @param function the function to call"]
    #[doc = " @param num_results the number of results"]
    #[doc = " @param results the pre-alloced pointer to get the results"]
    #[doc = " @param num_args the number of arguments"]
    #[doc = " @param args the arguments"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise and exception will be thrown,"]
    #[doc = "   the caller can call wasm_runtime_get_exception to get the exception"]
    #[doc = "   info."]
    pub fn wasm_runtime_call_wasm_a(
        exec_env: wasm_exec_env_t,
        function: wasm_function_inst_t,
        num_results: u32,
        results: *mut wasm_val_t,
        num_args: u32,
        args: *mut wasm_val_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Call the given WASM function of a WASM module instance with"]
    #[doc = " provided results space and variant arguments (bytecode and AoT)."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to call the function,"]
    #[doc = "   which must be created from wasm_create_exec_env()"]
    #[doc = " @param function the function to call"]
    #[doc = " @param num_results the number of results"]
    #[doc = " @param results the pre-alloced pointer to get the results"]
    #[doc = " @param num_args the number of arguments"]
    #[doc = " @param ... the variant arguments"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise and exception will be thrown,"]
    #[doc = "   the caller can call wasm_runtime_get_exception to get the exception"]
    #[doc = "   info."]
    pub fn wasm_runtime_call_wasm_v(
        exec_env: wasm_exec_env_t,
        function: wasm_function_inst_t,
        num_results: u32,
        results: *mut wasm_val_t,
        num_args: u32,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = " Call a function reference of a given WASM runtime instance with"]
    #[doc = " arguments."]
    #[doc = ""]
    #[doc = " Note: this can be used to call a function which is not exported"]
    #[doc = " by the module explicitly. You might consider it as an abstraction"]
    #[doc = " violation."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to call the function"]
    #[doc = "   which must be created from wasm_create_exec_env()"]
    #[doc = " @param element_index the function reference index, usually"]
    #[doc = "   prvovided by the caller of a registed native function"]
    #[doc = " @param argc the number of arguments"]
    #[doc = " @param argv the arguments.  If the function method has return value,"]
    #[doc = "   the first (or first two in case 64-bit return value) element of"]
    #[doc = "   argv stores the return value of the called WASM function after this"]
    #[doc = "   function returns."]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise and exception will be thrown,"]
    #[doc = "   the caller can call wasm_runtime_get_exception to get exception info."]
    pub fn wasm_runtime_call_indirect(
        exec_env: wasm_exec_env_t,
        element_index: u32,
        argc: u32,
        argv: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Find the unique main function from a WASM module instance"]
    #[doc = " and execute that function."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param argc the number of arguments"]
    #[doc = " @param argv the arguments array, if the main function has return value,"]
    #[doc = "   *(int*)argv stores the return value of the called main function after"]
    #[doc = "   this function returns."]
    #[doc = ""]
    #[doc = " @return true if the main function is called, false otherwise and exception"]
    #[doc = "   will be thrown, the caller can call wasm_runtime_get_exception to get"]
    #[doc = "   the exception info."]
    pub fn wasm_application_execute_main(
        module_inst: wasm_module_inst_t,
        argc: i32,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Find the specified function in argv[0] from a WASM module instance"]
    #[doc = " and execute that function."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param name the name of the function to execute."]
    #[doc = "  to indicate the module name via: $module_name$function_name"]
    #[doc = "  or just a function name: function_name"]
    #[doc = " @param argc the number of arguments"]
    #[doc = " @param argv the arguments array"]
    #[doc = ""]
    #[doc = " @return true if the specified function is called, false otherwise and"]
    #[doc = "   exception will be thrown, the caller can call wasm_runtime_get_exception"]
    #[doc = "   to get the exception info."]
    pub fn wasm_application_execute_func(
        module_inst: wasm_module_inst_t,
        name: *const ::std::os::raw::c_char,
        argc: i32,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get exception info of the WASM module instance."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = ""]
    #[doc = " @return the exception string"]
    pub fn wasm_runtime_get_exception(
        module_inst: wasm_module_inst_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set exception info of the WASM module instance."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = ""]
    #[doc = " @param exception the exception string"]
    pub fn wasm_runtime_set_exception(
        module_inst: wasm_module_inst_t,
        exception: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Clear exception info of the WASM module instance."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    pub fn wasm_runtime_clear_exception(module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Set custom data to WASM module instance."]
    #[doc = " Note:"]
    #[doc = "  If WAMR_BUILD_LIB_PTHREAD is enabled, this API"]
    #[doc = "  will spread the custom data to all threads"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param custom_data the custom data to be set"]
    pub fn wasm_runtime_set_custom_data(
        module_inst: wasm_module_inst_t,
        custom_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the custom data within a WASM module instance."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = ""]
    #[doc = " @return the custom data (NULL if not set yet)"]
    pub fn wasm_runtime_get_custom_data(
        module_inst: wasm_module_inst_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate memory from the heap of WASM module instance"]
    #[doc = ""]
    #[doc = " Note: wasm_runtime_module_malloc can call heap functions inside"]
    #[doc = " the module instance and thus cause a memory growth."]
    #[doc = " This API needs to be used very carefully when you have a native"]
    #[doc = " pointers to the module instance memory obtained with"]
    #[doc = " wasm_runtime_addr_app_to_native or similar APIs."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance which contains heap"]
    #[doc = " @param size the size bytes to allocate"]
    #[doc = " @param p_native_addr return native address of the allocated memory"]
    #[doc = "        if it is not NULL, and return NULL if memory malloc failed"]
    #[doc = ""]
    #[doc = " @return the allocated memory address, which is a relative offset to the"]
    #[doc = "         base address of the module instance's memory space. Note that"]
    #[doc = "         it is not an absolute address."]
    #[doc = "         Return non-zero if success, zero if failed."]
    pub fn wasm_runtime_module_malloc(
        module_inst: wasm_module_inst_t,
        size: u32,
        p_native_addr: *mut *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Free memory to the heap of WASM module instance"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance which contains heap"]
    #[doc = " @param ptr the pointer to free"]
    pub fn wasm_runtime_module_free(module_inst: wasm_module_inst_t, ptr: u32);
}
extern "C" {
    #[doc = " Allocate memory from the heap of WASM module instance and initialize"]
    #[doc = " the memory with src"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance which contains heap"]
    #[doc = " @param src the source data to copy"]
    #[doc = " @param size the size of the source data"]
    #[doc = ""]
    #[doc = " @return the allocated memory address, which is a relative offset to the"]
    #[doc = "         base address of the module instance's memory space. Note that"]
    #[doc = "         it is not an absolute address."]
    #[doc = "         Return non-zero if success, zero if failed."]
    pub fn wasm_runtime_module_dup_data(
        module_inst: wasm_module_inst_t,
        src: *const ::std::os::raw::c_char,
        size: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Validate the app address, check whether it belongs to WASM module"]
    #[doc = " instance's address space, or in its heap space or memory space."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param app_offset the app address to validate, which is a relative address"]
    #[doc = " @param size the size bytes of the app address"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise. If failed, an exception will"]
    #[doc = "         be thrown."]
    pub fn wasm_runtime_validate_app_addr(
        module_inst: wasm_module_inst_t,
        app_offset: u32,
        size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Similar to wasm_runtime_validate_app_addr(), except that the size parameter"]
    #[doc = " is not provided. This function validates the app string address, check"]
    #[doc = " whether it belongs to WASM module instance's address space, or in its heap"]
    #[doc = " space or memory space. Moreover, it checks whether it is the offset of a"]
    #[doc = " string that is end with '\\0'."]
    #[doc = ""]
    #[doc = " Note: The validation result, especially the NUL termination check,"]
    #[doc = " is not reliable for a module instance with multiple threads because"]
    #[doc = " other threads can modify the heap behind us."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param app_str_offset the app address of the string to validate, which is a"]
    #[doc = "        relative address"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise. If failed, an exception will"]
    #[doc = "         be thrown."]
    pub fn wasm_runtime_validate_app_str_addr(
        module_inst: wasm_module_inst_t,
        app_str_offset: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Validate the native address, check whether it belongs to WASM module"]
    #[doc = " instance's address space, or in its heap space or memory space."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param native_ptr the native address to validate, which is an absolute"]
    #[doc = "        address"]
    #[doc = " @param size the size bytes of the app address"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise. If failed, an exception will"]
    #[doc = "         be thrown."]
    pub fn wasm_runtime_validate_native_addr(
        module_inst: wasm_module_inst_t,
        native_ptr: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Convert app address(relative address) to native address(absolute address)"]
    #[doc = ""]
    #[doc = " Note that native addresses to module instance memory can be invalidated"]
    #[doc = " on a memory growth. (Except shared memory, whose native addresses are"]
    #[doc = " stable.)"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param app_offset the app adress"]
    #[doc = ""]
    #[doc = " @return the native address converted"]
    pub fn wasm_runtime_addr_app_to_native(
        module_inst: wasm_module_inst_t,
        app_offset: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Convert native address(absolute address) to app address(relative address)"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param native_ptr the native address"]
    #[doc = ""]
    #[doc = " @return the app address converted"]
    pub fn wasm_runtime_addr_native_to_app(
        module_inst: wasm_module_inst_t,
        native_ptr: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the app address range (relative address) that a app address belongs to"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param app_offset the app address to retrieve"]
    #[doc = " @param p_app_start_offset buffer to output the app start offset if not NULL"]
    #[doc = " @param p_app_end_offset buffer to output the app end offset if not NULL"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise."]
    pub fn wasm_runtime_get_app_addr_range(
        module_inst: wasm_module_inst_t,
        app_offset: u32,
        p_app_start_offset: *mut u32,
        p_app_end_offset: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the native address range (absolute address) that a native address"]
    #[doc = " belongs to"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance"]
    #[doc = " @param native_ptr the native address to retrieve"]
    #[doc = " @param p_native_start_addr buffer to output the native start address"]
    #[doc = "        if not NULL"]
    #[doc = " @param p_native_end_addr buffer to output the native end address"]
    #[doc = "        if not NULL"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise."]
    pub fn wasm_runtime_get_native_addr_range(
        module_inst: wasm_module_inst_t,
        native_ptr: *mut u8,
        p_native_start_addr: *mut *mut u8,
        p_native_end_addr: *mut *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Register native functions with same module name"]
    #[doc = ""]
    #[doc = " Note: The array `native_symbols` should not be read-only because the"]
    #[doc = " library can modify it in-place."]
    #[doc = ""]
    #[doc = " Note: After successful call of this function, the array `native_symbols`"]
    #[doc = " is owned by the library."]
    #[doc = ""]
    #[doc = " @param module_name the module name of the native functions"]
    #[doc = " @param native_symbols specifies an array of NativeSymbol structures which"]
    #[doc = "        contain the names, function pointers and signatures"]
    #[doc = "        Note: WASM runtime will not allocate memory to clone the data, so"]
    #[doc = "              user must ensure the array can be used forever"]
    #[doc = "        Meanings of letters in function signature:"]
    #[doc = "          'i': the parameter is i32 type"]
    #[doc = "          'I': the parameter is i64 type"]
    #[doc = "          'f': the parameter is f32 type"]
    #[doc = "          'F': the parameter is f64 type"]
    #[doc = "          'r': the parameter is externref type, it should be a uintptr_t in host"]
    #[doc = "          '*': the parameter is a pointer (i32 in WASM), and runtime will"]
    #[doc = "               auto check its boundary before calling the native function."]
    #[doc = "               If it is followed by '~', the checked length of the pointer"]
    #[doc = "               is gotten from the following parameter, if not, the checked"]
    #[doc = "               length of the pointer is 1."]
    #[doc = "          '~': the parameter is the pointer's length with i32 type, and must"]
    #[doc = "               follow after '*'"]
    #[doc = "          '$': the parameter is a string (i32 in WASM), and runtime will"]
    #[doc = "               auto check its boundary before calling the native function"]
    #[doc = " @param n_native_symbols specifies the number of native symbols in the array"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_register_natives(
        module_name: *const ::std::os::raw::c_char,
        native_symbols: *mut NativeSymbol,
        n_native_symbols: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Register native functions with same module name, similar to"]
    #[doc = "   wasm_runtime_register_natives, the difference is that runtime passes raw"]
    #[doc = " arguments to native API, which means that the native API should be defined as"]
    #[doc = "   void foo(wasm_exec_env_t exec_env, uint64 *args);"]
    #[doc = " and native API should extract arguments one by one from args array with macro"]
    #[doc = "   native_raw_get_arg"]
    #[doc = " and write the return value back to args[0] with macro"]
    #[doc = "   native_raw_return_type and native_raw_set_return"]
    pub fn wasm_runtime_register_natives_raw(
        module_name: *const ::std::os::raw::c_char,
        native_symbols: *mut NativeSymbol,
        n_native_symbols: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Undo wasm_runtime_register_natives or wasm_runtime_register_natives_raw"]
    #[doc = ""]
    #[doc = " @param module_name    Should be the same as the corresponding"]
    #[doc = "                       wasm_runtime_register_natives."]
    #[doc = "                       (Same in term of strcmp.)"]
    #[doc = ""]
    #[doc = " @param native_symbols Should be the same as the corresponding"]
    #[doc = "                       wasm_runtime_register_natives."]
    #[doc = "                       (Same in term of pointer comparison.)"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_runtime_unregister_natives(
        module_name: *const ::std::os::raw::c_char,
        native_symbols: *mut NativeSymbol,
    ) -> bool;
}
extern "C" {
    #[doc = " Get attachment of native function from execution environment"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment to retrieve"]
    #[doc = ""]
    #[doc = " @return the attachment of native function"]
    pub fn wasm_runtime_get_function_attachment(
        exec_env: wasm_exec_env_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set user data to execution environment."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    #[doc = " @param user_data the user data to be set"]
    pub fn wasm_runtime_set_user_data(
        exec_env: wasm_exec_env_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the user data within execution environment."]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    #[doc = ""]
    #[doc = " @return the user data (NULL if not set yet)"]
    pub fn wasm_runtime_get_user_data(exec_env: wasm_exec_env_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Dump runtime memory consumption, including:"]
    #[doc = "     Exec env memory consumption"]
    #[doc = "     WASM module memory consumption"]
    #[doc = "     WASM module instance memory consumption"]
    #[doc = "     stack and app heap used info"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    pub fn wasm_runtime_dump_mem_consumption(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Dump runtime performance profiler data of each function"]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance to profile"]
    pub fn wasm_runtime_dump_perf_profiling(module_inst: wasm_module_inst_t);
}
pub type wasm_thread_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: wasm_exec_env_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type wasm_thread_t = usize;
extern "C" {
    #[doc = " Set the max thread num per cluster."]
    #[doc = ""]
    #[doc = " @param num maximum thread num"]
    pub fn wasm_runtime_set_max_thread_num(num: u32);
}
extern "C" {
    #[doc = " Spawn a new exec_env, the spawned exec_env"]
    #[doc = "   can be used in other threads"]
    #[doc = ""]
    #[doc = " @param num the original exec_env"]
    #[doc = ""]
    #[doc = " @return the spawned exec_env if success, NULL otherwise"]
    pub fn wasm_runtime_spawn_exec_env(exec_env: wasm_exec_env_t) -> wasm_exec_env_t;
}
extern "C" {
    #[doc = " Destroy the spawned exec_env"]
    #[doc = ""]
    #[doc = " @param exec_env the spawned exec_env"]
    pub fn wasm_runtime_destroy_spawned_exec_env(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Spawn a thread from the given exec_env"]
    #[doc = ""]
    #[doc = " @param exec_env the original exec_env"]
    #[doc = " @param tid thread id to be returned to the caller"]
    #[doc = " @param callback the callback function provided by the user"]
    #[doc = " @param arg the arguments passed to the callback"]
    #[doc = ""]
    #[doc = " @return 0 if success, -1 otherwise"]
    pub fn wasm_runtime_spawn_thread(
        exec_env: wasm_exec_env_t,
        tid: *mut wasm_thread_t,
        callback: wasm_thread_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Wait a spawned thread to terminate"]
    #[doc = ""]
    #[doc = " @param tid thread id"]
    #[doc = " @param retval if not NULL, output the return value of the thread"]
    #[doc = ""]
    #[doc = " @return 0 if success, error number otherwise"]
    pub fn wasm_runtime_join_thread(
        tid: wasm_thread_t,
        retval: *mut *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Map external object to an internal externref index: if the index"]
    #[doc = "   has been created, return it, otherwise create the index."]
    #[doc = ""]
    #[doc = " @param module_inst the WASM module instance that the extern object"]
    #[doc = "        belongs to"]
    #[doc = " @param extern_obj the external object to be mapped"]
    #[doc = " @param p_externref_idx return externref index of the external object"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_externref_obj2ref(
        module_inst: wasm_module_inst_t,
        extern_obj: *mut ::std::os::raw::c_void,
        p_externref_idx: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve the external object from an internal externref index"]
    #[doc = ""]
    #[doc = " @param externref_idx the externref index to retrieve"]
    #[doc = " @param p_extern_obj return the mapped external object of"]
    #[doc = "        the externref index"]
    #[doc = ""]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_externref_ref2obj(
        externref_idx: u32,
        p_extern_obj: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Retain an extern object which is mapped to the internal externref"]
    #[doc = "   so that the object won't be cleaned during extern object reclaim"]
    #[doc = "   if it isn't used."]
    #[doc = ""]
    #[doc = " @param externref_idx the externref index of an external object"]
    #[doc = "        to retain"]
    #[doc = " @return true if success, false otherwise"]
    pub fn wasm_externref_retain(externref_idx: u32) -> bool;
}
extern "C" {
    #[doc = " Dump the call stack to stdout"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    pub fn wasm_runtime_dump_call_stack(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Get the size required to store the call stack contents, including"]
    #[doc = " the space for terminating null byte ('\\0')"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    #[doc = ""]
    #[doc = " @return size required to store the contents, 0 means error"]
    pub fn wasm_runtime_get_call_stack_buf_size(exec_env: wasm_exec_env_t) -> u32;
}
extern "C" {
    #[doc = " Dump the call stack to buffer."]
    #[doc = ""]
    #[doc = " @note this function is not thread-safe, please only use this API"]
    #[doc = "       when the exec_env is not executing"]
    #[doc = ""]
    #[doc = " @param exec_env the execution environment"]
    #[doc = " @param buf buffer to store the dumped content"]
    #[doc = " @param len length of the buffer"]
    #[doc = ""]
    #[doc = " @return bytes dumped to the buffer, including the terminating null"]
    #[doc = "         byte ('\\0'), 0 means error and data in buf may be invalid"]
    pub fn wasm_runtime_dump_call_stack_to_buf(
        exec_env: wasm_exec_env_t,
        buf: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get a custom section by name"]
    #[doc = ""]
    #[doc = " @param module_comm the module to find"]
    #[doc = " @param name name of the custom section"]
    #[doc = " @param len return the length of the content if found"]
    #[doc = ""]
    #[doc = " @return Custom section content (not including the name length"]
    #[doc = "         and name string) if found, NULL otherwise"]
    pub fn wasm_runtime_get_custom_section(
        module_comm: wasm_module_t,
        name: *const ::std::os::raw::c_char,
        len: *mut u32,
    ) -> *const u8;
}
extern "C" {
    #[doc = " Get WAMR semantic version"]
    pub fn wasm_runtime_get_version(major: *mut u32, minor: *mut u32, patch: *mut u32);
}
extern "C" {
    #[doc = " Check whether an import func `(import <module_name> <func_name> (func ...))` is linked or not"]
    #[doc = " with runtime registered natvie functions"]
    pub fn wasm_runtime_is_import_func_linked(
        module_name: *const ::std::os::raw::c_char,
        func_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether an import global `(import <module_name> <global_name> (global ...))` is linked or not"]
    #[doc = " with runtime registered natvie globals"]
    pub fn wasm_runtime_is_import_global_linked(
        module_name: *const ::std::os::raw::c_char,
        global_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
